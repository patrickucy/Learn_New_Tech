day02
{AM1}
一、MVC  
	1. 什么是？
		大型的设计模式
		Model 模型
			数据 业务结构
		View 视图
			看见的界面
			纯展示数据、可交互的
		Controller 控制器（ViewController）
			连接模型和视图
	2. 	为什么要用MVC？
		1)	同样一个数据，可能需要多个显示的样式
			[案例：hp和sp多重显示同步问题]
		2)	同样的显示，可能会展示不同的数据
			[UILabel]
			[UIHpLabel]
				hpText
			[UISpLabel]
				spText
			[UIDexLabel]
				dexText
			[UIDefLabel]
		9) 	不是为了现在方便，是为了将来方便
	3.	iOS中的MVC都是什么
		Model 模型
			1)	数据类 Entity实体  
			2)	业务逻辑
				Online：更多的是网络请求数据
				Local：大量的业务逻辑
			3)	Core Data
		View 视图
			1)	UIView的子类 -  一般展示数据
			2)	UIControl的子类 －  控件交互数据
			3)	大型的View - TableView CollectionView
		
		Controller 控制器
			1)	Content View Controller 自定义的整合界面
			2)	配对大型View使用的 ViewController
				UITableViewController
				UICollectionViewController
			3)	控制器的控制器
				UINavigationController
				UITabBarController
				UISplitController
		实际问题
			1)	数据量大
			2)	界面有限
			Controller 就是要从Model中选取合适的数据
			放在合适的View中
	4.	怎么做（怎么分离）
		[图]
		{AM2}
		M	- 	C	-	V
		C -> V	属性直接访问
			中文：通过property持有V层的对象
			代码1：self.label.text = @"hello world";
			代码2：_label.text = @"hello world";
		V -> C	事件驱动
			1)
			中文：Target-Action 设计模式
			1> C层向V层声明我对某个事件的发生感兴趣
			你需要写（或者连线）
			代码：addTarget:forAction:forControlEvents:
			2> V层在事件发生时，通过以下代码执行C的消息
			系统写好了（除非你自己开发的控件支持TA，需要自己写）
			代码：[target performSelector:selector];
			2)
			中文：Delegation 委托设计模式
			遗留代码：
			内部代码：
		C -> M 	属性直接访问
			中文：通过property持有M层的对象
			代码：self.currentUserData.username = @"小ios";
		M -> C KVO
			类似广播的机制（观察者设计模式）
			当M层数据被修改时，通知关心这个数据的C层
		C : M -> V
			当收到通知时（观察的数据被改变时）
			self.usernameLabel.text = 
			self.currentUserData.username;
	5.	注意事项
		1)	在iOS的MVC理念下，不允许M和V之间有任何的交互
		2)	也不是说必须要严格MVC，有的时候为了开发效率
			有的时候需求不稳定，etc
			
二、UITextField
	1.	收键盘事件处理
		Target-Action
		DidEndOnExit事件
	2.	FirstResponder
		界面里只有一个能成为第一响应者
		如果这个是可输入的，键盘会自动弹出
		如果这个不是可输入的，键盘会自动收回
	3.	代码
		1) 当前输入的键盘 撤销第一响应
		[self.textField resignFirstResponder];
		2) 或者 另外一个view 成为第一响应
		[self becomeFirstResponder];
	4. [P04]
		1) 基本要求
			点击登陆之后
			在最下面的label显示"用户名:密码"
		2) 对帐号textField的要求
			点击键盘右下角，直接跳到密码成为第一响应者
			帐号的右下角应该是next按键
		3) 对密码textField的要求
			点击键盘右下角，键盘收起
			密码的右下角应该是Done按键
{PM1}
	5. 	UITextFieldDelegate
		1)	委托设计模式
			有些对象（类）它会有一个委托property
			用于汇报日常信息和一些自己无法决定的事情
			
			如果向获取这些日常信息或者想帮助这个对象处理它自己无法处理的事情
			那么你就必须给这个对象设置委托
		2)	常见的委托消息样式
			Delegate / Delegation
			Datasource

			should
			will
			did
		3)	实现委托的步骤
			1> 	设置对象A的delegate属性为对象B
				UITextField * textField = [alloc] init];
				textField.delegate = self;
				[self.view addSub....:]
				[release];
				对象A会将日常信息汇报给对象B
				对象A还会在无法自己决定的时候通过委托询问对象B
			2>	B对象要声明符合A对象委托的协议
				<UITextFieldDelegate>
			3>	选择自己感兴趣的信息（消息方法），覆盖实现
				- (BOOL)textFieldShouldReturn:(UITextField *)textField{
    				[textField resignFirstResponder];
			效果> A对象发生事件时会导致调用B对象的消息
	{PM2}
	6.	UIAlertView
		[P04 升级]
		覆盖UIAlertViewDelegate对应的消息
		点击登陆后 出现错误提示
			点击返回 没事
			点击 重新输入 则清除密码输入框内容并变为第一响应者
			
	{PM3}
	 	做练习
	 	0. 	代码搞清楚
	 	1.	UIActionSheet (UIStepper)
	 		destructiveTitle 红色按钮
	 		[showInView:self.view];
	 	2.	登陆的P04要跑通，尽力理解注释
	 		MVC
	 		对着代码 找 一、4.
	 	3.	类似的本地自聊
	 		点“我说” 在右边出现label
	 		点“他说” 在左边出现label
	 		label的高度都是40
	 		左边的label距离左边10
	 		右边的label距离右边10
	 		UIFont * font = [UIFont systemFontOfSize:12];
	 		CGSize size = [@"hello" sizeWithFont:font];
	 		label 的宽度 size.width + 20;
	 		1) 	他说的背景颜色是灰色 字是黑色
	 			我说的背景颜色是蓝色 字是黑色
	 	4.	要求P04的数据从plist文件里搞出来
	 	
	 	
	 		
			
			
	
			
		
		
			
			
			
		 
		
		
		
				
				
				
		
		
			
		
		
	